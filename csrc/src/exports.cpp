// Generated by using torchexport::export() -> do not edit by hand
#include "torchsparse/torchsparse.h"
#include <lantern/types.h>
void * p_torchsparse_last_error = NULL;

TORCHSPARSE_API void* torchsparse_last_error()
{
  return p_torchsparse_last_error;
}

TORCHSPARSE_API void torchsparse_last_error_clear()
{
  p_torchsparse_last_error = NULL;
}

torch::Tensor sparse_ind2ptr (torch::Tensor ind, int64_t M);
TORCHSPARSE_API void* _sparse_ind2ptr (void* ind, int64_t M) {
  try {
    return  make_raw::Tensor(sparse_ind2ptr(from_raw::Tensor(ind), M));
  } TORCHSPARSE_HANDLE_EXCEPTION
  return (void*) NULL;
}
torch::Tensor sparse_ptr2ind (torch::Tensor ptr, int64_t E);
TORCHSPARSE_API void* _sparse_ptr2ind (void* ptr, int64_t E) {
  try {
    return  make_raw::Tensor(sparse_ptr2ind(from_raw::Tensor(ptr), E));
  } TORCHSPARSE_HANDLE_EXCEPTION
  return (void*) NULL;
}
torch::Tensor sparse_random_walk (torch::Tensor rowptr, torch::Tensor col, torch::Tensor start, int64_t walk_length);
TORCHSPARSE_API void* _sparse_random_walk (void* rowptr, void* col, void* start, int64_t walk_length) {
  try {
    return  make_raw::Tensor(sparse_random_walk(from_raw::Tensor(rowptr), from_raw::Tensor(col), from_raw::Tensor(start), walk_length));
  } TORCHSPARSE_HANDLE_EXCEPTION
  return (void*) NULL;
}

// Generated by using torchexport::export() -> do not edit by hand
#pragma once

#ifdef _WIN32
#ifndef TORCHSPARSE_HEADERS_ONLY
#define TORCHSPARSE_API extern "C" __declspec(dllexport)
#else
#define TORCHSPARSE_API extern "C" __declspec(dllimport)
#endif
#else
#define TORCHSPARSE_API extern "C"
#endif

#ifndef TORCHSPARSE_HANDLE_EXCEPTION
#define TORCHSPARSE_HANDLE_EXCEPTION                                  \
catch(const std::exception& ex) {                                  \
  p_torchsparse_last_error = make_raw::string(ex.what());             \
} catch (std::string& ex) {                                        \
  p_torchsparse_last_error = make_raw::string(ex);                    \
} catch (...) {                                                    \
  p_torchsparse_last_error = make_raw::string("Unknown error. ");     \
}
#endif

void host_exception_handler ();
extern void* p_torchsparse_last_error;
TORCHSPARSE_API void* torchsparse_last_error ();
TORCHSPARSE_API void torchsparse_last_error_clear();

TORCHSPARSE_API void* _sparse_ind2ptr (void* ind, int64_t M);
TORCHSPARSE_API void* _sparse_ptr2ind (void* ptr, int64_t E);
TORCHSPARSE_API void* _sparse_partition (void* rowptr, void* col, void* optional_value, int64_t num_parts, bool recursive);
TORCHSPARSE_API void* _sparse_partition2 (void* rowptr, void* col, void* optional_value, void* optional_node_weight, int64_t num_parts, bool recursive);
TORCHSPARSE_API void* _sparse_mt_partition (void* rowptr, void* col, void* optional_value, void* optional_node_weight, int64_t num_parts, bool recursive, int64_t num_workers);
TORCHSPARSE_API void* _sparse_relabel (void* col, void* idx);
TORCHSPARSE_API void* _sparse_random_walk (void* rowptr, void* col, void* start, int64_t walk_length);
TORCHSPARSE_API void* _sparse_spmm_sum (void* opt_row, void* rowptr, void* col, void* opt_value, void* opt_colptr, void* opt_csr2csc, void* mat);
TORCHSPARSE_API void* _sparse_spmm_mean (void* opt_row, void* rowptr, void* col, void* opt_value, void* opt_rowcount, void* opt_colptr, void* opt_csr2csc, void* mat);
TORCHSPARSE_API void* _sparse_spmm_min (void* rowptr, void* col, void* opt_value, void* mat);
TORCHSPARSE_API void* _sparse_spmm_max (void* rowptr, void* col, void* opt_value, void* mat);
TORCHSPARSE_API void* _sparse_spspmm_sum (void* rowptrA, void* colA, void* optional_valueA, void* rowptrB, void* colB, void* optional_valueB, int64_t K);
TORCHSPARSE_API void* _sparse_relabel_one_hop (void* rowptr, void* col, void* optional_value, void* idx, bool bipartite);
TORCHSPARSE_API void _delete_tensor_pair (void* x);
TORCHSPARSE_API void* _tensor_pair_get_first (void* x);
TORCHSPARSE_API void* _tensor_pair_get_second (void* x);
TORCHSPARSE_API void _delete_tensor_tensor_optionaltensor (void* x);
TORCHSPARSE_API void* _tensor_tensor_optionaltensor_get_first (void* x);
TORCHSPARSE_API void* _tensor_tensor_optionaltensor_get_second (void* x);
TORCHSPARSE_API void* _tensor_tensor_optionaltensor_get_third (void* x);
TORCHSPARSE_API void _delete_tensor_tensor_optionaltensor_tensor (void* x);
TORCHSPARSE_API void* _tensor_tensor_optionaltensor_tensor_get_first (void* x);
TORCHSPARSE_API void* _tensor_tensor_optionaltensor_tensor_get_second (void* x);
TORCHSPARSE_API void* _tensor_tensor_optionaltensor_tensor_get_third (void* x);
TORCHSPARSE_API void* _tensor_tensor_optionaltensor_tensor_get_fourth (void* x);

#ifdef RCPP_VERSION
inline void* sparse_ind2ptr (void* ind, int64_t M) {
  auto ret =  _sparse_ind2ptr(ind, M);
  host_exception_handler();
  return ret;
}
inline void* sparse_ptr2ind (void* ptr, int64_t E) {
  auto ret =  _sparse_ptr2ind(ptr, E);
  host_exception_handler();
  return ret;
}
inline void* sparse_partition (void* rowptr, void* col, void* optional_value, int64_t num_parts, bool recursive) {
  auto ret =  _sparse_partition(rowptr, col, optional_value, num_parts, recursive);
  host_exception_handler();
  return ret;
}
inline void* sparse_partition2 (void* rowptr, void* col, void* optional_value, void* optional_node_weight, int64_t num_parts, bool recursive) {
  auto ret =  _sparse_partition2(rowptr, col, optional_value, optional_node_weight, num_parts, recursive);
  host_exception_handler();
  return ret;
}
inline void* sparse_mt_partition (void* rowptr, void* col, void* optional_value, void* optional_node_weight, int64_t num_parts, bool recursive, int64_t num_workers) {
  auto ret =  _sparse_mt_partition(rowptr, col, optional_value, optional_node_weight, num_parts, recursive, num_workers);
  host_exception_handler();
  return ret;
}
inline void* sparse_relabel (void* col, void* idx) {
  auto ret =  _sparse_relabel(col, idx);
  host_exception_handler();
  return ret;
}
inline void* sparse_random_walk (void* rowptr, void* col, void* start, int64_t walk_length) {
  auto ret =  _sparse_random_walk(rowptr, col, start, walk_length);
  host_exception_handler();
  return ret;
}
inline void* sparse_spmm_sum (void* opt_row, void* rowptr, void* col, void* opt_value, void* opt_colptr, void* opt_csr2csc, void* mat) {
  auto ret =  _sparse_spmm_sum(opt_row, rowptr, col, opt_value, opt_colptr, opt_csr2csc, mat);
  host_exception_handler();
  return ret;
}
inline void* sparse_spmm_mean (void* opt_row, void* rowptr, void* col, void* opt_value, void* opt_rowcount, void* opt_colptr, void* opt_csr2csc, void* mat) {
  auto ret =  _sparse_spmm_mean(opt_row, rowptr, col, opt_value, opt_rowcount, opt_colptr, opt_csr2csc, mat);
  host_exception_handler();
  return ret;
}
inline void* sparse_spmm_min (void* rowptr, void* col, void* opt_value, void* mat) {
  auto ret =  _sparse_spmm_min(rowptr, col, opt_value, mat);
  host_exception_handler();
  return ret;
}
inline void* sparse_spmm_max (void* rowptr, void* col, void* opt_value, void* mat) {
  auto ret =  _sparse_spmm_max(rowptr, col, opt_value, mat);
  host_exception_handler();
  return ret;
}
inline void* sparse_spspmm_sum (void* rowptrA, void* colA, void* optional_valueA, void* rowptrB, void* colB, void* optional_valueB, int64_t K) {
  auto ret =  _sparse_spspmm_sum(rowptrA, colA, optional_valueA, rowptrB, colB, optional_valueB, K);
  host_exception_handler();
  return ret;
}
inline void* sparse_relabel_one_hop (void* rowptr, void* col, void* optional_value, void* idx, bool bipartite) {
  auto ret =  _sparse_relabel_one_hop(rowptr, col, optional_value, idx, bipartite);
  host_exception_handler();
  return ret;
}
inline void delete_tensor_pair (void* x) {
   _delete_tensor_pair(x);
  host_exception_handler();
  
}
inline void* tensor_pair_get_first (void* x) {
  auto ret =  _tensor_pair_get_first(x);
  host_exception_handler();
  return ret;
}
inline void* tensor_pair_get_second (void* x) {
  auto ret =  _tensor_pair_get_second(x);
  host_exception_handler();
  return ret;
}
inline void delete_tensor_tensor_optionaltensor (void* x) {
   _delete_tensor_tensor_optionaltensor(x);
  host_exception_handler();
  
}
inline void* tensor_tensor_optionaltensor_get_first (void* x) {
  auto ret =  _tensor_tensor_optionaltensor_get_first(x);
  host_exception_handler();
  return ret;
}
inline void* tensor_tensor_optionaltensor_get_second (void* x) {
  auto ret =  _tensor_tensor_optionaltensor_get_second(x);
  host_exception_handler();
  return ret;
}
inline void* tensor_tensor_optionaltensor_get_third (void* x) {
  auto ret =  _tensor_tensor_optionaltensor_get_third(x);
  host_exception_handler();
  return ret;
}
inline void delete_tensor_tensor_optionaltensor_tensor (void* x) {
   _delete_tensor_tensor_optionaltensor_tensor(x);
  host_exception_handler();
  
}
inline void* tensor_tensor_optionaltensor_tensor_get_first (void* x) {
  auto ret =  _tensor_tensor_optionaltensor_tensor_get_first(x);
  host_exception_handler();
  return ret;
}
inline void* tensor_tensor_optionaltensor_tensor_get_second (void* x) {
  auto ret =  _tensor_tensor_optionaltensor_tensor_get_second(x);
  host_exception_handler();
  return ret;
}
inline void* tensor_tensor_optionaltensor_tensor_get_third (void* x) {
  auto ret =  _tensor_tensor_optionaltensor_tensor_get_third(x);
  host_exception_handler();
  return ret;
}
inline void* tensor_tensor_optionaltensor_tensor_get_fourth (void* x) {
  auto ret =  _tensor_tensor_optionaltensor_tensor_get_fourth(x);
  host_exception_handler();
  return ret;
}
#endif // RCPP_VERSION
